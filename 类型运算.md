[text](https://github.com/jiaozitang/ts-demo?tab=readme-ov-file)
[text](https://blog.maxiaobo.com.cn/type-challenge/dist/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%81%9A-ts-%E4%BD%93%E6%93%8D)


返回值类型 ReturnType
```ts
// 写个函数
const f = () => {
    return { x: 10, y: 3 };
}
// 单纯的typeof获取的是它的完整类型,显然是个函数,结果是:() => { x: number; y: number; }
type a = typeof f
// ReturnType获取返回值类型,结果就只有返回值的type,结果是:{ x: number; y: number; }
type P = ReturnType<typeof f>;
```

模板字符串类型 `${Array[keyof Array]}` 也可以叫做索引访问类型
TS4.1新增
用于取得一个key-value的type中的value
目的和定义一个enum然后从中取值类似,之所以要这么用,是因为在类型运算中无法直接获得value,因为不知道需要那个key,且本来最终就想要取得所有的value作为type的一部分
这种方法可以使得最终的type中出现string,如果想要进一步限制string只能是一些固定的值的话
```ts
type DB = {
    mysql: "MySQL",
    postgres: "PostgreSQL",
    sqlite: "SQLite",
    mssql: "Microsoft SQL Server",
}
// keyof DB取出来所有的key,也就是前面的mysql,postgres等,再通过DB[keyof DB]取出其对应的值,${}动态字符串的写法和js相同
type DBKeys = `I prefer using ${DB[keyof DB]}`;
// 结果是
type DBKeys = "I prefer using MySQL" | "I prefer using PostgreSQL" | "I prefer using SQLite" | "I prefer using Microsoft SQL Server"
```
注意,实际上这种写法也可以用在enum上,但是写法特殊,且由于现在版本的ts默认erasableSyntaxOnly:true,不能使用enum,所以不推荐使用enum
另外enum的写法和type也不一样,更加复杂

索引访问类型
ts中可以使用索引的形式获取类型
```ts
type Person = { age: number; name: string };
// 写法和获取数组值相同
type Age = Person["age"]; 
// 结果是获取对象中对应的属性的类型
// type Age = number
```
这种写法可以扩展,用于获取数组中的对象的类型
```ts
const Persons = [
    { name: "Alice", age: 15 },
    { adult: true, age: 23 },
    { name: "Eve", age: 38 },
];
// 注意,除非数组中每个对象的类型完全一样,否则结果也是一个数组
type Person = typeof Persons[number]; 
// 结果如下,缺少的使用可选属性,类型undefined
type Person = {
    name: string;
    age: number;
    adult?: undefined;
} | {
    adult: boolean;
    age: number;
    name?: undefined;
}
```

删除修饰符
```ts
// 对于原本存在的修饰符,使用-可以在新的type中删除,如下,原本T中有可选属性和readonly,都可以在新的type中删掉
type MyRequired<T> = {
  [k in keyof T]-?: T[k];
};
 
type Writable<T> = {
  -readonly [k in keyof T]: T[k];
};
```
添加修饰符
```ts
// 对于原本不存在的修饰符,比如readonly,可以在新的type中添加上去
type Readonly<T> = {
    readonly [P in keyof T]: T[P];
};
```

# 条件类型
条件类型是各种复杂类型运算的基础
最常见的条件类型如下
```ts
// 也就是实际的type是通过=右侧计算得出的,type本身没有具体定义,由于真正需要用到条件类型的时候,都是由于不知道实际上作为条件的T到底什么,所以其实基本都会搭配泛型使用,毕竟给定了类型其实是不需要计算得出结果的
type IsString<T> = T extends string ? true : false;
// 上面的条件类型的理解是:判断T extends string的正确与否,正确则返回true,不正确返回false,也就意味着这个type,实际上只有true或false两种结果
// 也就是针对条件结果,它的实际类型是根据三元运算符决定的
const a: IsString<"a"> = true;
```
完整的计算逻辑是,给定一个泛型T作为参数,条件类型对其进行计算,最终返回结果
```ts
// 上面的条件类型的计算过程是
// 参数是<T>
// 根据三元做判断T extends string
// 最终给出结果true或者false
```
## 条件类型中的extends及其运算优先级
在类型运算中,extends起到的是判断类型是否兼容的作用,和继承的extends不一样,原因是TS的类型是结构化类型
对于`T extends U ? true : false`这样的条件类型,判断结果取决于U中存在的属性和方法是否在T中都存在,如果都存在,结果为true
```ts
type f = {
    name:string,
    age:number
}

type k = {
    name:string,
    age:number,
}
// 针对上面两个type写一个条件类型
type A<T> = f extends T ? true : false;
// 结果是true
type result = A<k>
```

可选属性的判断
针对可选属性,还是需要判断U中的属性是不是都在T中存在,只是因为出现了可选属性,所以判断结果可能不同
结果一共有多种可能
```ts
type T = {
    height:number
}

type U = {
    height?:number
}

type A<T,U> = T extends U ? true : false;
// 1.T没有可选属性,U存在可选属性,结果是true
type result = A<T,U>

type T = {
    height?:number
}

type U = {
    height:number
}

type A<T,U> = T extends U ? true : false;
// 2.T存在可选属性,U没有可选属性,结果是false,因为不满足U要求属性必须存在
type result = A<T,U>

type T = {
    height?:number
}

type U = {
    height?:string
}

type A<T,U> = T extends U ? true : false;
// 3.特殊情况,T和U都是可选属性的时候,虽然理论上应该是true,但实际上结果为false,因为可选属性本质上是联合类型的语法糖type | undefined,两边都是可选属性,但是类型不一样的时候,相当于在比较string | undefined和number | undefined是否兼容,结果当然是不兼容
// 所以,如果是height?:number和height?:number,则结果为true,需要注意
type result = A<T,U>
```

readonly的判断
不管那个type中的属性为readonly,结果都为true
```ts
type T = {
    readonly height:number
}

type U = {
    height:number
}

type A<T,U> = T extends U ? true : false;
// 结果为true
type result = A<T,U>
```

对于运算优先级,extends本身是在做判断,所以右边必定是个三元运算符
```ts
// (...params: any) => infer R 是函数签名,也就是F必须是这个函数签名的实例,其实已经很明确了,所以不用再加括号
F extends (...params: any) => infer R
```
```ts


// 针对这个type,如果不考虑泛型,它其实就是一个函数类型的type,这很好理解
type MyReturnType<F extends Function> = F extends (...params: any) => infer R ? R : never;
```

## 条件类型中的类型推断 infer
条件类型中不支持泛型,所以才设计了infer作为替代
infer必须使用在条件类型的extends后面,且使用infer推断的类型必须在条件类型中使用,否则报错
infer的含义是让TS自行推断类型,infer U指U的类型
```ts
// 下面这个需要infer原因是对于函数签名 (...params: any) => infer R 需要的是类型,而R本身是个对象,也就是条件类型中不能使用泛型导致了需要设计infer作为替代
type MyReturnType<F extends Function> = F extends (...params: any) => infer R ? R : never;
// 如果条件类型支持泛型的话可能就会变成这样，如果对泛型函数(<T>() => T)比较熟可能这样会比较好理解
// type MyReturnType<F extends Function> = <R> F extends (...params: any) => R ? R : never;

// 下面的结果是{ combined: string } 
type RType = MyReturnType<(input: string, input2: number) => { combined: string }>; 
```

递归类型
和模板字面量一样,在TS4.1新增
如同递归函数是它自身引用了它自己一样,TS的递归类型是在这个类型中用到了它自己
使用递归是因为在类型运算中无法使用循环,只能使用递归作为替代
TS的递归类型需要在条件类型中使用,原因是因为需要终止条件,避免死循环
```ts
// 简单的递归类型,其实就是针对一个类型T,如果它满足一定条件,就继续执行逻辑delivery<T,U>,知道不再满足条件,返回需要的值
type delivery<T,U> = T extends U ? delivery<T,U> : 需要的返回值;
```
一个用于获取多层promise的最深层promise返回值类型的递归类型
```ts
// P extends Promise<infer ValueType>:对于一个给定的泛型参数P,判断它是不是一个嵌套promise
// Promise<infer ValueType> 由于不止一层promise,所以除了最后一层,实际上ValueType也是个promise,所以实际上在判断它是不是个嵌套的promise
// 如果是嵌套promise,则调用它自己,并把ValueType作为下一次调用的泛型参数,由于判断的时候,使用的是Promise<infer ValueType>,这意味着每次执行递归,promise都少了最外面的一层,直到最后一层promise,它的泛型是基本数据类型,也就是它的返回类型
// 最后一次调用的时候,DeepPromiseValueType<ValueType>的泛型ValueType变成了基本数据类型,不再符合P extends Promise<infer ValueType>的要求,于是返回P,也就是最深层的返回值类型
type DeepPromiseValueType<P> = P extends Promise<infer ValueType>
  ? DeepPromiseValueType<ValueType>
  : P
```

解决lazy导致的类型计算不出来
由于TS的类型运算默认是lazy的,用不到的它不给算,所以可以利用一定会成立且需要计算的类型作为三元条件强制类型计算
```ts
// 原理十分的简单,前面的T extends any一定是成立的,所以其实永远都不会到never那里去,一定最终得到的是原来的类型计算逻辑
T extends any ? {原本的类型计算逻辑} :never
```


模拟switch-case
TS的类型中没有if-else和switch-case,只能通过三目运算符模拟
```ts
type MyType<T> = T extends string
  ? "string"
  : T extends number
    ? "number"
    : T extends boolean
      ? "boolean"
      : T extends undefined
        ? "undefined"
        : T extends Function
          ? "function"
          : "object";
```